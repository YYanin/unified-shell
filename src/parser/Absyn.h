/* File generated by the BNF Converter (bnfc 2.9.5). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* Word;

/********************   Forward Declarations    ***********************/
struct Input_;
typedef struct Input_ *Input;

struct Job_;
typedef struct Job_ *Job;

struct ListJob_;
typedef struct ListJob_ *ListJob;

struct CommandLine_;
typedef struct CommandLine_ *CommandLine;

struct OptRedir_;
typedef struct OptRedir_ *OptRedir;

struct Pipeline_;
typedef struct Pipeline_ *Pipeline;

struct CommandPart_;
typedef struct CommandPart_ *CommandPart;

struct WordComponent_;
typedef struct WordComponent_ *WordComponent;

struct ListWordComponent_;
typedef struct ListWordComponent_ *ListWordComponent;

struct ListCommandLine_;
typedef struct ListCommandLine_ *ListCommandLine;

/********************   Abstract Syntax Classes    ********************/

struct Input_
{
  enum { is_StartInput } kind;
  union
  {
    struct { ListJob listjob_; } startinput_;
  } u;
};

Input make_StartInput(ListJob p0);

struct Job_
{
  enum { is_OneJobFG, is_OneJobBG } kind;
  union
  {
    struct { CommandLine commandline_; } onejobfg_;
    struct { CommandLine commandline_; } onejobbg_;
  } u;
};

Job make_OneJobFG(CommandLine p0);
Job make_OneJobBG(CommandLine p0);

struct ListJob_
{
  enum { is_SeparatorJob, is_ConsJob } kind;
  union
  {
    struct { Job job_; ListJob listjob_; } separatorjob_;
    struct { Job job_; } consjob_;
  } u;
};

ListJob make_SeparatorJob(Job p0, ListJob p1);
ListJob make_ConsJob(Job p0);

struct CommandLine_
{
  enum { is_MkCmdLine } kind;
  union
  {
    struct { OptRedir optredir_; Pipeline pipeline_; } mkcmdline_;
  } u;
};

CommandLine make_MkCmdLine(Pipeline p0, OptRedir p1);

struct OptRedir_
{
  enum { is_NoRedir, is_InOutRedir, is_OutInRedir, is_OutRedir, is_InRedir } kind;
  union
  {
    struct { Word word_1, word_2; } inoutredir_;
    struct { Word word_1, word_2; } outinredir_;
    struct { Word word_; } outredir_;
    struct { Word word_; } inredir_;
  } u;
};

OptRedir make_NoRedir(void);
OptRedir make_InOutRedir(Word p0, Word p1);
OptRedir make_OutInRedir(Word p0, Word p1);
OptRedir make_OutRedir(Word p0);
OptRedir make_InRedir(Word p0);

struct Pipeline_
{
  enum { is_Single, is_Pipe } kind;
  union
  {
    struct { CommandPart commandpart_; } single_;
    struct { CommandPart commandpart_; Pipeline pipeline_; } pipe_;
  } u;
};

Pipeline make_Single(CommandPart p0);
Pipeline make_Pipe(CommandPart p0, Pipeline p1);

struct CommandPart_
{
  enum { is_Cmd, is_CmdWithArgs, is_CmdAssign, is_VarExpand, is_IfCmd, is_IfElseCmd } kind;
  union
  {
    struct { Word word_; } cmd_;
    struct { ListWordComponent listwordcomponent_; Word word_; } cmdwithargs_;
    struct { Word word_1, word_2; } cmdassign_;
    struct { Word word_; } varexpand_;
    struct { ListCommandLine listcommandline_; Pipeline pipeline_; } ifcmd_;
    struct { ListCommandLine listcommandline_1, listcommandline_2; Pipeline pipeline_; } ifelsecmd_;
  } u;
};

CommandPart make_Cmd(Word p0);
CommandPart make_CmdWithArgs(Word p0, ListWordComponent p1);
CommandPart make_CmdAssign(Word p0, Word p1);
CommandPart make_VarExpand(Word p0);
CommandPart make_IfCmd(Pipeline p0, ListCommandLine p1);
CommandPart make_IfElseCmd(Pipeline p0, ListCommandLine p1, ListCommandLine p2);

struct WordComponent_
{
  enum { is_LitWord, is_VarWord, is_SubCmd } kind;
  union
  {
    struct { Word word_; } litword_;
    struct { Word word_; } varword_;
    struct { Pipeline pipeline_; } subcmd_;
  } u;
};

WordComponent make_LitWord(Word p0);
WordComponent make_VarWord(Word p0);
WordComponent make_SubCmd(Pipeline p0);

struct ListWordComponent_
{
  enum { is_SingleWordComponent, is_ConsWordComponent } kind;
  union
  {
    struct { WordComponent wordcomponent_; } singlewordcomponent_;
    struct { ListWordComponent listwordcomponent_; WordComponent wordcomponent_; } conswordcomponent_;
  } u;
};

ListWordComponent make_SingleWordComponent(WordComponent p0);
ListWordComponent make_ConsWordComponent(WordComponent p0, ListWordComponent p1);

struct ListCommandLine_
{
  enum { is_ConsCmdLine, is_NilCmdLine } kind;
  union
  {
    struct { CommandLine commandline_; ListCommandLine listcommandline_; } conscmdline_;
  } u;
};

ListCommandLine make_ConsCmdLine(CommandLine p0, ListCommandLine p1);
ListCommandLine make_NilCmdLine(void);

/***************************   Cloning   ******************************/

Input clone_Input(Input p);
Job clone_Job(Job p);
ListJob clone_ListJob(ListJob p);
CommandLine clone_CommandLine(CommandLine p);
OptRedir clone_OptRedir(OptRedir p);
Pipeline clone_Pipeline(Pipeline p);
CommandPart clone_CommandPart(CommandPart p);
WordComponent clone_WordComponent(WordComponent p);
ListWordComponent clone_ListWordComponent(ListWordComponent p);
ListCommandLine clone_ListCommandLine(ListCommandLine p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Input(Input p);
void free_Job(Job p);
void free_ListJob(ListJob p);
void free_CommandLine(CommandLine p);
void free_OptRedir(OptRedir p);
void free_Pipeline(Pipeline p);
void free_CommandPart(CommandPart p);
void free_WordComponent(WordComponent p);
void free_ListWordComponent(ListWordComponent p);
void free_ListCommandLine(ListCommandLine p);


#endif
