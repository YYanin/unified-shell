/* File generated by the BNF Converter (bnfc 2.9.5). */

/*** Pretty Printer and Abstract Syntax Viewer ***/

#include <ctype.h>   /* isspace */
#include <stddef.h>  /* size_t */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "Printer.h"

#define INDENT_WIDTH 2

int _n_;
char *buf_;
size_t cur_;
size_t buf_size;

/* You may wish to change the renderC functions */
void renderC(Char c)
{
  if (c == '{')
  {
     onEmptyLine();
     bufAppendC(c);
     _n_ = _n_ + INDENT_WIDTH;
     bufAppendC('\n');
     indent();
  }
  else if (c == '(' || c == '[')
     bufAppendC(c);
  else if (c == ')' || c == ']')
  {
     removeTrailingWhitespace();
     bufAppendC(c);
     bufAppendC(' ');
  }
  else if (c == '}')
  {
     _n_ = _n_ - INDENT_WIDTH;
     onEmptyLine();
     bufAppendC(c);
     bufAppendC('\n');
     indent();
  }
  else if (c == ',')
  {
     removeTrailingWhitespace();
     bufAppendC(c);
     bufAppendC(' ');
  }
  else if (c == ';')
  {
     removeTrailingWhitespace();
     bufAppendC(c);
     bufAppendC('\n');
     indent();
  }
  else if (c == ' ') bufAppendC(c);
  else if (c == 0) return;
  else
  {
     bufAppendC(c);
     bufAppendC(' ');
  }
}

int allIsSpace(String s)
{
  char c;
  while ((c = *s++))
    if (! isspace(c)) return 0;
  return 1;
}

void renderS(String s)
{
  if (*s) /* s[0] != '\0', string s not empty */
  {
    if (allIsSpace(s)) {
      backup();
      bufAppendS(s);
    } else {
      bufAppendS(s);
      bufAppendC(' ');
    }
  }
}

void indent(void)
{
  int n = _n_;
  while (--n >= 0)
    bufAppendC(' ');
}

void backup(void)
{
  if (cur_ && buf_[cur_ - 1] == ' ')
    buf_[--cur_] = 0;
}

void removeTrailingSpaces()
{
  while (cur_ && buf_[cur_ - 1] == ' ') --cur_;
  buf_[cur_] = 0;
}

void removeTrailingWhitespace()
{
  while (cur_ && (buf_[cur_ - 1] == ' ' || buf_[cur_ - 1] == '\n')) --cur_;
  buf_[cur_] = 0;
}

void onEmptyLine()
{
  removeTrailingSpaces();
  if (cur_ && buf_[cur_ - 1 ] != '\n') bufAppendC('\n');
  indent();
}
char *printInput(Input p)
{
  _n_ = 0;
  bufReset();
  ppInput(p, 0);
  return buf_;
}
char *showInput(Input p)
{
  _n_ = 0;
  bufReset();
  shInput(p);
  return buf_;
}
void ppInput(Input p, int _i_)
{
  switch(p->kind)
  {
  case is_StartInput:
    if (_i_ > 0) renderC(_L_PAREN);
    ppListJob(p->u.startinput_.listjob_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Input!\n");
    exit(1);
  }
}

void ppJob(Job p, int _i_)
{
  switch(p->kind)
  {
  case is_OneJobFG:
    if (_i_ > 0) renderC(_L_PAREN);
    ppCommandLine(p->u.onejobfg_.commandline_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_OneJobBG:
    if (_i_ > 0) renderC(_L_PAREN);
    ppCommandLine(p->u.onejobbg_.commandline_, 0);
    renderC('&');
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Job!\n");
    exit(1);
  }
}

void ppListJob(ListJob p, int _i_)
{
  switch(p->kind)
  {
  case is_SeparatorJob:
    if (_i_ > 0) renderC(_L_PAREN);
    ppJob(p->u.separatorjob_.job_, 0);
    renderC(';');
    ppListJob(p->u.separatorjob_.listjob_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_ConsJob:
    if (_i_ > 0) renderC(_L_PAREN);
    ppJob(p->u.consjob_.job_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing ListJob!\n");
    exit(1);
  }
}

void ppCommandLine(CommandLine p, int _i_)
{
  switch(p->kind)
  {
  case is_MkCmdLine:
    if (_i_ > 0) renderC(_L_PAREN);
    ppPipeline(p->u.mkcmdline_.pipeline_, 0);
    ppOptRedir(p->u.mkcmdline_.optredir_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing CommandLine!\n");
    exit(1);
  }
}

void ppOptRedir(OptRedir p, int _i_)
{
  switch(p->kind)
  {
  case is_NoRedir:
    if (_i_ > 0) renderC(_L_PAREN);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_InOutRedir:
    if (_i_ > 0) renderC(_L_PAREN);
    renderC('<');
    ppIdent(p->u.inoutredir_.word_1, 0);
    renderC('>');
    ppIdent(p->u.inoutredir_.word_2, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_OutInRedir:
    if (_i_ > 0) renderC(_L_PAREN);
    renderC('>');
    ppIdent(p->u.outinredir_.word_1, 0);
    renderC('<');
    ppIdent(p->u.outinredir_.word_2, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_OutRedir:
    if (_i_ > 0) renderC(_L_PAREN);
    renderC('>');
    ppIdent(p->u.outredir_.word_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_InRedir:
    if (_i_ > 0) renderC(_L_PAREN);
    renderC('<');
    ppIdent(p->u.inredir_.word_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing OptRedir!\n");
    exit(1);
  }
}

void ppPipeline(Pipeline p, int _i_)
{
  switch(p->kind)
  {
  case is_Single:
    if (_i_ > 0) renderC(_L_PAREN);
    ppCommandPart(p->u.single_.commandpart_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_Pipe:
    if (_i_ > 0) renderC(_L_PAREN);
    ppCommandPart(p->u.pipe_.commandpart_, 0);
    renderC('|');
    ppPipeline(p->u.pipe_.pipeline_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing Pipeline!\n");
    exit(1);
  }
}

void ppCommandPart(CommandPart p, int _i_)
{
  switch(p->kind)
  {
  case is_Cmd:
    if (_i_ > 0) renderC(_L_PAREN);
    ppIdent(p->u.cmd_.word_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_CmdWithArgs:
    if (_i_ > 0) renderC(_L_PAREN);
    ppIdent(p->u.cmdwithargs_.word_, 0);
    ppListWordComponent(p->u.cmdwithargs_.listwordcomponent_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_CmdAssign:
    if (_i_ > 0) renderC(_L_PAREN);
    ppIdent(p->u.cmdassign_.word_1, 0);
    renderC('=');
    ppIdent(p->u.cmdassign_.word_2, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_VarExpand:
    if (_i_ > 0) renderC(_L_PAREN);
    renderC('$');
    ppIdent(p->u.varexpand_.word_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_IfCmd:
    if (_i_ > 0) renderC(_L_PAREN);
    renderS("if");
    ppPipeline(p->u.ifcmd_.pipeline_, 0);
    renderS("then");
    ppListCommandLine(p->u.ifcmd_.listcommandline_, 0);
    renderS("fi");
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_IfElseCmd:
    if (_i_ > 0) renderC(_L_PAREN);
    renderS("if");
    ppPipeline(p->u.ifelsecmd_.pipeline_, 0);
    renderS("then");
    ppListCommandLine(p->u.ifelsecmd_.listcommandline_1, 0);
    renderS("else");
    ppListCommandLine(p->u.ifelsecmd_.listcommandline_2, 0);
    renderS("fi");
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing CommandPart!\n");
    exit(1);
  }
}

void ppWordComponent(WordComponent p, int _i_)
{
  switch(p->kind)
  {
  case is_LitWord:
    if (_i_ > 0) renderC(_L_PAREN);
    ppIdent(p->u.litword_.word_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_VarWord:
    if (_i_ > 0) renderC(_L_PAREN);
    renderC('$');
    ppIdent(p->u.varword_.word_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_SubCmd:
    if (_i_ > 0) renderC(_L_PAREN);
    renderC('`');
    ppPipeline(p->u.subcmd_.pipeline_, 0);
    renderC('`');
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing WordComponent!\n");
    exit(1);
  }
}

void ppListWordComponent(ListWordComponent p, int _i_)
{
  switch(p->kind)
  {
  case is_SingleWordComponent:
    if (_i_ > 0) renderC(_L_PAREN);
    ppWordComponent(p->u.singlewordcomponent_.wordcomponent_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_ConsWordComponent:
    if (_i_ > 0) renderC(_L_PAREN);
    ppWordComponent(p->u.conswordcomponent_.wordcomponent_, 0);
    ppListWordComponent(p->u.conswordcomponent_.listwordcomponent_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing ListWordComponent!\n");
    exit(1);
  }
}

void ppListCommandLine(ListCommandLine p, int _i_)
{
  switch(p->kind)
  {
  case is_ConsCmdLine:
    if (_i_ > 0) renderC(_L_PAREN);
    ppCommandLine(p->u.conscmdline_.commandline_, 0);
    ppListCommandLine(p->u.conscmdline_.listcommandline_, 0);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  case is_NilCmdLine:
    if (_i_ > 0) renderC(_L_PAREN);
    if (_i_ > 0) renderC(_R_PAREN);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when printing ListCommandLine!\n");
    exit(1);
  }
}

void ppInteger(Integer n, int i)
{
  char tmp[20];
  sprintf(tmp, "%d", n);
  renderS(tmp);
}
void ppDouble(Double d, int i)
{
  char tmp[24];
  sprintf(tmp, "%.15g", d);
  renderS(tmp);
}
void ppChar(Char c, int i)
{
  bufAppendC('\'');
  bufEscapeC(c);
  bufAppendC('\'');
  bufAppendC(' ');
}
void ppString(String s, int i)
{
  bufAppendC('\"');
  bufEscapeS(s);
  bufAppendC('\"');
  bufAppendC(' ');
}
void ppIdent(String s, int i)
{
  renderS(s);
}

void ppWord(String s, int i)
{
  renderS(s);
}


void shInput(Input p)
{
  switch(p->kind)
  {
  case is_StartInput:
    bufAppendC('(');

    bufAppendS("StartInput");

    bufAppendC(' ');

    shListJob(p->u.startinput_.listjob_);

    bufAppendC(')');

    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing Input!\n");
    exit(1);
  }
}

void shJob(Job p)
{
  switch(p->kind)
  {
  case is_OneJobFG:
    bufAppendC('(');

    bufAppendS("OneJobFG");

    bufAppendC(' ');

    shCommandLine(p->u.onejobfg_.commandline_);

    bufAppendC(')');

    break;
  case is_OneJobBG:
    bufAppendC('(');

    bufAppendS("OneJobBG");

    bufAppendC(' ');

    shCommandLine(p->u.onejobbg_.commandline_);

    bufAppendC(')');

    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing Job!\n");
    exit(1);
  }
}

void shListJob(ListJob p)
{
  switch(p->kind)
  {
  case is_SeparatorJob:
    bufAppendC('(');

    bufAppendS("SeparatorJob");

    bufAppendC(' ');

    shJob(p->u.separatorjob_.job_);
  bufAppendC(' ');
    shListJob(p->u.separatorjob_.listjob_);

    bufAppendC(')');

    break;
  case is_ConsJob:
    bufAppendC('(');

    bufAppendS("ConsJob");

    bufAppendC(' ');

    shJob(p->u.consjob_.job_);

    bufAppendC(')');

    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing ListJob!\n");
    exit(1);
  }
}

void shCommandLine(CommandLine p)
{
  switch(p->kind)
  {
  case is_MkCmdLine:
    bufAppendC('(');

    bufAppendS("MkCmdLine");

    bufAppendC(' ');

    shPipeline(p->u.mkcmdline_.pipeline_);
  bufAppendC(' ');
    shOptRedir(p->u.mkcmdline_.optredir_);

    bufAppendC(')');

    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing CommandLine!\n");
    exit(1);
  }
}

void shOptRedir(OptRedir p)
{
  switch(p->kind)
  {
  case is_NoRedir:

    bufAppendS("NoRedir");




    break;
  case is_InOutRedir:
    bufAppendC('(');

    bufAppendS("InOutRedir");

    bufAppendC(' ');

    shIdent(p->u.inoutredir_.word_1);
  bufAppendC(' ');
    shIdent(p->u.inoutredir_.word_2);

    bufAppendC(')');

    break;
  case is_OutInRedir:
    bufAppendC('(');

    bufAppendS("OutInRedir");

    bufAppendC(' ');

    shIdent(p->u.outinredir_.word_1);
  bufAppendC(' ');
    shIdent(p->u.outinredir_.word_2);

    bufAppendC(')');

    break;
  case is_OutRedir:
    bufAppendC('(');

    bufAppendS("OutRedir");

    bufAppendC(' ');

    shIdent(p->u.outredir_.word_);

    bufAppendC(')');

    break;
  case is_InRedir:
    bufAppendC('(');

    bufAppendS("InRedir");

    bufAppendC(' ');

    shIdent(p->u.inredir_.word_);

    bufAppendC(')');

    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing OptRedir!\n");
    exit(1);
  }
}

void shPipeline(Pipeline p)
{
  switch(p->kind)
  {
  case is_Single:
    bufAppendC('(');

    bufAppendS("Single");

    bufAppendC(' ');

    shCommandPart(p->u.single_.commandpart_);

    bufAppendC(')');

    break;
  case is_Pipe:
    bufAppendC('(');

    bufAppendS("Pipe");

    bufAppendC(' ');

    shCommandPart(p->u.pipe_.commandpart_);
  bufAppendC(' ');
    shPipeline(p->u.pipe_.pipeline_);

    bufAppendC(')');

    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing Pipeline!\n");
    exit(1);
  }
}

void shCommandPart(CommandPart p)
{
  switch(p->kind)
  {
  case is_Cmd:
    bufAppendC('(');

    bufAppendS("Cmd");

    bufAppendC(' ');

    shIdent(p->u.cmd_.word_);

    bufAppendC(')');

    break;
  case is_CmdWithArgs:
    bufAppendC('(');

    bufAppendS("CmdWithArgs");

    bufAppendC(' ');

    shIdent(p->u.cmdwithargs_.word_);
  bufAppendC(' ');
    shListWordComponent(p->u.cmdwithargs_.listwordcomponent_);

    bufAppendC(')');

    break;
  case is_CmdAssign:
    bufAppendC('(');

    bufAppendS("CmdAssign");

    bufAppendC(' ');

    shIdent(p->u.cmdassign_.word_1);
  bufAppendC(' ');
    shIdent(p->u.cmdassign_.word_2);

    bufAppendC(')');

    break;
  case is_VarExpand:
    bufAppendC('(');

    bufAppendS("VarExpand");

    bufAppendC(' ');

    shIdent(p->u.varexpand_.word_);

    bufAppendC(')');

    break;
  case is_IfCmd:
    bufAppendC('(');

    bufAppendS("IfCmd");

    bufAppendC(' ');

    shPipeline(p->u.ifcmd_.pipeline_);
  bufAppendC(' ');
    shListCommandLine(p->u.ifcmd_.listcommandline_);

    bufAppendC(')');

    break;
  case is_IfElseCmd:
    bufAppendC('(');

    bufAppendS("IfElseCmd");

    bufAppendC(' ');

    shPipeline(p->u.ifelsecmd_.pipeline_);
  bufAppendC(' ');
    shListCommandLine(p->u.ifelsecmd_.listcommandline_1);
  bufAppendC(' ');
    shListCommandLine(p->u.ifelsecmd_.listcommandline_2);

    bufAppendC(')');

    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing CommandPart!\n");
    exit(1);
  }
}

void shWordComponent(WordComponent p)
{
  switch(p->kind)
  {
  case is_LitWord:
    bufAppendC('(');

    bufAppendS("LitWord");

    bufAppendC(' ');

    shIdent(p->u.litword_.word_);

    bufAppendC(')');

    break;
  case is_VarWord:
    bufAppendC('(');

    bufAppendS("VarWord");

    bufAppendC(' ');

    shIdent(p->u.varword_.word_);

    bufAppendC(')');

    break;
  case is_SubCmd:
    bufAppendC('(');

    bufAppendS("SubCmd");

    bufAppendC(' ');

    shPipeline(p->u.subcmd_.pipeline_);

    bufAppendC(')');

    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing WordComponent!\n");
    exit(1);
  }
}

void shListWordComponent(ListWordComponent p)
{
  switch(p->kind)
  {
  case is_SingleWordComponent:
    bufAppendC('(');

    bufAppendS("SingleWordComponent");

    bufAppendC(' ');

    shWordComponent(p->u.singlewordcomponent_.wordcomponent_);

    bufAppendC(')');

    break;
  case is_ConsWordComponent:
    bufAppendC('(');

    bufAppendS("ConsWordComponent");

    bufAppendC(' ');

    shWordComponent(p->u.conswordcomponent_.wordcomponent_);
  bufAppendC(' ');
    shListWordComponent(p->u.conswordcomponent_.listwordcomponent_);

    bufAppendC(')');

    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing ListWordComponent!\n");
    exit(1);
  }
}

void shListCommandLine(ListCommandLine p)
{
  switch(p->kind)
  {
  case is_ConsCmdLine:
    bufAppendC('(');

    bufAppendS("ConsCmdLine");

    bufAppendC(' ');

    shCommandLine(p->u.conscmdline_.commandline_);
  bufAppendC(' ');
    shListCommandLine(p->u.conscmdline_.listcommandline_);

    bufAppendC(')');

    break;
  case is_NilCmdLine:

    bufAppendS("NilCmdLine");




    break;

  default:
    fprintf(stderr, "Error: bad kind field when showing ListCommandLine!\n");
    exit(1);
  }
}

void shInteger(Integer i)
{
  char tmp[20];
  sprintf(tmp, "%d", i);
  bufAppendS(tmp);
}
void shDouble(Double d)
{
  char tmp[24];
  sprintf(tmp, "%.15g", d);
  bufAppendS(tmp);
}
void shChar(Char c)
{
  bufAppendC('\'');
  bufEscapeC(c);
  bufAppendC('\'');
}
void shString(String s)
{
  bufAppendC('\"');
  bufEscapeS(s);
  bufAppendC('\"');
}
void shIdent(String s)
{
  bufAppendC('\"');
  bufAppendS(s);
  bufAppendC('\"');
}

void shWord(String s)
{
  bufAppendC('\"');
  bufEscapeS(s);
  bufAppendC('\"');
}


void bufEscapeS(const char *s)
{
  if (s) while (*s) bufEscapeC(*s++);
}
void bufEscapeC(const char c)
{
  switch(c)
  {
    case '\f': bufAppendS("\\f" ); break;
    case '\n': bufAppendS("\\n" ); break;
    case '\r': bufAppendS("\\r" ); break;
    case '\t': bufAppendS("\\t" ); break;
    case '\v': bufAppendS("\\v" ); break;
    case '\\': bufAppendS("\\\\"); break;
    case '\'': bufAppendS("\\'" ); break;
    case '\"': bufAppendS("\\\""); break;
    default: bufAppendC(c);
  }
}

void bufAppendS(const char *s)
{
  size_t len = strlen(s);
  size_t n;
  while (cur_ + len >= buf_size)
  {
    buf_size *= 2; /* Double the buffer size */
    resizeBuffer();
  }
  for(n = 0; n < len; n++)
  {
    buf_[cur_ + n] = s[n];
  }
  cur_ += len;
  buf_[cur_] = 0;
}
void bufAppendC(const char c)
{
  if (cur_ + 1 >= buf_size)
  {
    buf_size *= 2; /* Double the buffer size */
    resizeBuffer();
  }
  buf_[cur_] = c;
  cur_++;
  buf_[cur_] = 0;
}
void bufReset(void)
{
  cur_ = 0;
  buf_size = BUFFER_INITIAL;
  resizeBuffer();
  memset(buf_, 0, buf_size);
}
void resizeBuffer(void)
{
  char *temp = (char *) malloc(buf_size);
  if (!temp)
  {
    fprintf(stderr, "Error: Out of memory while attempting to grow buffer!\n");
    exit(1);
  }
  if (buf_)
  {
    strncpy(temp, buf_, buf_size); /* peteg: strlcpy is safer, but not POSIX/ISO C. */
    free(buf_);
  }
  buf_ = temp;
}
char *buf_;
size_t cur_, buf_size;

