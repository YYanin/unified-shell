/* File generated by the BNF Converter (bnfc 2.9.5). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   StartInput    ********************/

Input make_StartInput(ListJob p1)
{
    Input tmp = (Input) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating StartInput!\n");
        exit(1);
    }
    tmp->kind = is_StartInput;
    tmp->u.startinput_.listjob_ = p1;
    return tmp;
}

/********************   OneJobFG    ********************/

Job make_OneJobFG(CommandLine p1)
{
    Job tmp = (Job) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OneJobFG!\n");
        exit(1);
    }
    tmp->kind = is_OneJobFG;
    tmp->u.onejobfg_.commandline_ = p1;
    return tmp;
}

/********************   OneJobBG    ********************/

Job make_OneJobBG(CommandLine p1)
{
    Job tmp = (Job) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OneJobBG!\n");
        exit(1);
    }
    tmp->kind = is_OneJobBG;
    tmp->u.onejobbg_.commandline_ = p1;
    return tmp;
}

/********************   SeparatorJob    ********************/

ListJob make_SeparatorJob(Job p1, ListJob p2)
{
    ListJob tmp = (ListJob) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SeparatorJob!\n");
        exit(1);
    }
    tmp->kind = is_SeparatorJob;
    tmp->u.separatorjob_.job_ = p1;
    tmp->u.separatorjob_.listjob_ = p2;
    return tmp;
}

/********************   ConsJob    ********************/

ListJob make_ConsJob(Job p1)
{
    ListJob tmp = (ListJob) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConsJob!\n");
        exit(1);
    }
    tmp->kind = is_ConsJob;
    tmp->u.consjob_.job_ = p1;
    return tmp;
}

/********************   MkCmdLine    ********************/

CommandLine make_MkCmdLine(Pipeline p1, OptRedir p2)
{
    CommandLine tmp = (CommandLine) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MkCmdLine!\n");
        exit(1);
    }
    tmp->kind = is_MkCmdLine;
    tmp->u.mkcmdline_.pipeline_ = p1;
    tmp->u.mkcmdline_.optredir_ = p2;
    return tmp;
}

/********************   NoRedir    ********************/

OptRedir make_NoRedir()
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NoRedir!\n");
        exit(1);
    }
    tmp->kind = is_NoRedir;
    return tmp;
}

/********************   InOutRedir    ********************/

OptRedir make_InOutRedir(Word p1, Word p2)
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating InOutRedir!\n");
        exit(1);
    }
    tmp->kind = is_InOutRedir;
    tmp->u.inoutredir_.word_1 = p1;
    tmp->u.inoutredir_.word_2 = p2;
    return tmp;
}

/********************   OutInRedir    ********************/

OptRedir make_OutInRedir(Word p1, Word p2)
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OutInRedir!\n");
        exit(1);
    }
    tmp->kind = is_OutInRedir;
    tmp->u.outinredir_.word_1 = p1;
    tmp->u.outinredir_.word_2 = p2;
    return tmp;
}

/********************   OutRedir    ********************/

OptRedir make_OutRedir(Word p1)
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OutRedir!\n");
        exit(1);
    }
    tmp->kind = is_OutRedir;
    tmp->u.outredir_.word_ = p1;
    return tmp;
}

/********************   InRedir    ********************/

OptRedir make_InRedir(Word p1)
{
    OptRedir tmp = (OptRedir) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating InRedir!\n");
        exit(1);
    }
    tmp->kind = is_InRedir;
    tmp->u.inredir_.word_ = p1;
    return tmp;
}

/********************   Single    ********************/

Pipeline make_Single(CommandPart p1)
{
    Pipeline tmp = (Pipeline) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Single!\n");
        exit(1);
    }
    tmp->kind = is_Single;
    tmp->u.single_.commandpart_ = p1;
    return tmp;
}

/********************   Pipe    ********************/

Pipeline make_Pipe(CommandPart p1, Pipeline p2)
{
    Pipeline tmp = (Pipeline) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Pipe!\n");
        exit(1);
    }
    tmp->kind = is_Pipe;
    tmp->u.pipe_.commandpart_ = p1;
    tmp->u.pipe_.pipeline_ = p2;
    return tmp;
}

/********************   Cmd    ********************/

CommandPart make_Cmd(Word p1)
{
    CommandPart tmp = (CommandPart) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Cmd!\n");
        exit(1);
    }
    tmp->kind = is_Cmd;
    tmp->u.cmd_.word_ = p1;
    return tmp;
}

/********************   CmdWithArgs    ********************/

CommandPart make_CmdWithArgs(Word p1, ListWordComponent p2)
{
    CommandPart tmp = (CommandPart) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CmdWithArgs!\n");
        exit(1);
    }
    tmp->kind = is_CmdWithArgs;
    tmp->u.cmdwithargs_.word_ = p1;
    tmp->u.cmdwithargs_.listwordcomponent_ = p2;
    return tmp;
}

/********************   CmdAssign    ********************/

CommandPart make_CmdAssign(Word p1, Word p2)
{
    CommandPart tmp = (CommandPart) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CmdAssign!\n");
        exit(1);
    }
    tmp->kind = is_CmdAssign;
    tmp->u.cmdassign_.word_1 = p1;
    tmp->u.cmdassign_.word_2 = p2;
    return tmp;
}

/********************   VarExpand    ********************/

CommandPart make_VarExpand(Word p1)
{
    CommandPart tmp = (CommandPart) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VarExpand!\n");
        exit(1);
    }
    tmp->kind = is_VarExpand;
    tmp->u.varexpand_.word_ = p1;
    return tmp;
}

/********************   IfCmd    ********************/

CommandPart make_IfCmd(Pipeline p1, ListCommandLine p2)
{
    CommandPart tmp = (CommandPart) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating IfCmd!\n");
        exit(1);
    }
    tmp->kind = is_IfCmd;
    tmp->u.ifcmd_.pipeline_ = p1;
    tmp->u.ifcmd_.listcommandline_ = p2;
    return tmp;
}

/********************   IfElseCmd    ********************/

CommandPart make_IfElseCmd(Pipeline p1, ListCommandLine p2, ListCommandLine p3)
{
    CommandPart tmp = (CommandPart) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating IfElseCmd!\n");
        exit(1);
    }
    tmp->kind = is_IfElseCmd;
    tmp->u.ifelsecmd_.pipeline_ = p1;
    tmp->u.ifelsecmd_.listcommandline_1 = p2;
    tmp->u.ifelsecmd_.listcommandline_2 = p3;
    return tmp;
}

/********************   LitWord    ********************/

WordComponent make_LitWord(Word p1)
{
    WordComponent tmp = (WordComponent) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LitWord!\n");
        exit(1);
    }
    tmp->kind = is_LitWord;
    tmp->u.litword_.word_ = p1;
    return tmp;
}

/********************   VarWord    ********************/

WordComponent make_VarWord(Word p1)
{
    WordComponent tmp = (WordComponent) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VarWord!\n");
        exit(1);
    }
    tmp->kind = is_VarWord;
    tmp->u.varword_.word_ = p1;
    return tmp;
}

/********************   SubCmd    ********************/

WordComponent make_SubCmd(Pipeline p1)
{
    WordComponent tmp = (WordComponent) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SubCmd!\n");
        exit(1);
    }
    tmp->kind = is_SubCmd;
    tmp->u.subcmd_.pipeline_ = p1;
    return tmp;
}

/********************   SingleWordComponent    ********************/

ListWordComponent make_SingleWordComponent(WordComponent p1)
{
    ListWordComponent tmp = (ListWordComponent) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SingleWordComponent!\n");
        exit(1);
    }
    tmp->kind = is_SingleWordComponent;
    tmp->u.singlewordcomponent_.wordcomponent_ = p1;
    return tmp;
}

/********************   ConsWordComponent    ********************/

ListWordComponent make_ConsWordComponent(WordComponent p1, ListWordComponent p2)
{
    ListWordComponent tmp = (ListWordComponent) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConsWordComponent!\n");
        exit(1);
    }
    tmp->kind = is_ConsWordComponent;
    tmp->u.conswordcomponent_.wordcomponent_ = p1;
    tmp->u.conswordcomponent_.listwordcomponent_ = p2;
    return tmp;
}

/********************   ConsCmdLine    ********************/

ListCommandLine make_ConsCmdLine(CommandLine p1, ListCommandLine p2)
{
    ListCommandLine tmp = (ListCommandLine) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConsCmdLine!\n");
        exit(1);
    }
    tmp->kind = is_ConsCmdLine;
    tmp->u.conscmdline_.commandline_ = p1;
    tmp->u.conscmdline_.listcommandline_ = p2;
    return tmp;
}

/********************   NilCmdLine    ********************/

ListCommandLine make_NilCmdLine()
{
    ListCommandLine tmp = (ListCommandLine) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NilCmdLine!\n");
        exit(1);
    }
    tmp->kind = is_NilCmdLine;
    return tmp;
}

/***************************   Cloning   ******************************/

Input clone_Input(Input p)
{
  switch(p->kind)
  {
  case is_StartInput:
    return make_StartInput (clone_ListJob(p->u.startinput_.listjob_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Input!\n");
    exit(1);
  }
}

Job clone_Job(Job p)
{
  switch(p->kind)
  {
  case is_OneJobFG:
    return make_OneJobFG (clone_CommandLine(p->u.onejobfg_.commandline_));

  case is_OneJobBG:
    return make_OneJobBG (clone_CommandLine(p->u.onejobbg_.commandline_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Job!\n");
    exit(1);
  }
}

ListJob clone_ListJob(ListJob p)
{
  switch(p->kind)
  {
  case is_SeparatorJob:
    return make_SeparatorJob
      ( clone_Job(p->u.separatorjob_.job_)
      , clone_ListJob(p->u.separatorjob_.listjob_)
      );

  case is_ConsJob:
    return make_ConsJob (clone_Job(p->u.consjob_.job_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning ListJob!\n");
    exit(1);
  }
}

CommandLine clone_CommandLine(CommandLine p)
{
  switch(p->kind)
  {
  case is_MkCmdLine:
    return make_MkCmdLine
      ( clone_Pipeline(p->u.mkcmdline_.pipeline_)
      , clone_OptRedir(p->u.mkcmdline_.optredir_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning CommandLine!\n");
    exit(1);
  }
}

OptRedir clone_OptRedir(OptRedir p)
{
  switch(p->kind)
  {
  case is_NoRedir:
    return make_NoRedir ();

  case is_InOutRedir:
    return make_InOutRedir
      ( strdup(p->u.inoutredir_.word_1)
      , strdup(p->u.inoutredir_.word_2)
      );

  case is_OutInRedir:
    return make_OutInRedir
      ( strdup(p->u.outinredir_.word_1)
      , strdup(p->u.outinredir_.word_2)
      );

  case is_OutRedir:
    return make_OutRedir (strdup(p->u.outredir_.word_));

  case is_InRedir:
    return make_InRedir (strdup(p->u.inredir_.word_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning OptRedir!\n");
    exit(1);
  }
}

Pipeline clone_Pipeline(Pipeline p)
{
  switch(p->kind)
  {
  case is_Single:
    return make_Single (clone_CommandPart(p->u.single_.commandpart_));

  case is_Pipe:
    return make_Pipe
      ( clone_CommandPart(p->u.pipe_.commandpart_)
      , clone_Pipeline(p->u.pipe_.pipeline_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Pipeline!\n");
    exit(1);
  }
}

CommandPart clone_CommandPart(CommandPart p)
{
  switch(p->kind)
  {
  case is_Cmd:
    return make_Cmd (strdup(p->u.cmd_.word_));

  case is_CmdWithArgs:
    return make_CmdWithArgs
      ( strdup(p->u.cmdwithargs_.word_)
      , clone_ListWordComponent(p->u.cmdwithargs_.listwordcomponent_)
      );

  case is_CmdAssign:
    return make_CmdAssign
      ( strdup(p->u.cmdassign_.word_1)
      , strdup(p->u.cmdassign_.word_2)
      );

  case is_VarExpand:
    return make_VarExpand (strdup(p->u.varexpand_.word_));

  case is_IfCmd:
    return make_IfCmd
      ( clone_Pipeline(p->u.ifcmd_.pipeline_)
      , clone_ListCommandLine(p->u.ifcmd_.listcommandline_)
      );

  case is_IfElseCmd:
    return make_IfElseCmd
      ( clone_Pipeline(p->u.ifelsecmd_.pipeline_)
      , clone_ListCommandLine(p->u.ifelsecmd_.listcommandline_1)
      , clone_ListCommandLine(p->u.ifelsecmd_.listcommandline_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning CommandPart!\n");
    exit(1);
  }
}

WordComponent clone_WordComponent(WordComponent p)
{
  switch(p->kind)
  {
  case is_LitWord:
    return make_LitWord (strdup(p->u.litword_.word_));

  case is_VarWord:
    return make_VarWord (strdup(p->u.varword_.word_));

  case is_SubCmd:
    return make_SubCmd (clone_Pipeline(p->u.subcmd_.pipeline_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning WordComponent!\n");
    exit(1);
  }
}

ListWordComponent clone_ListWordComponent(ListWordComponent p)
{
  switch(p->kind)
  {
  case is_SingleWordComponent:
    return make_SingleWordComponent (clone_WordComponent(p->u.singlewordcomponent_.wordcomponent_));

  case is_ConsWordComponent:
    return make_ConsWordComponent
      ( clone_WordComponent(p->u.conswordcomponent_.wordcomponent_)
      , clone_ListWordComponent(p->u.conswordcomponent_.listwordcomponent_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ListWordComponent!\n");
    exit(1);
  }
}

ListCommandLine clone_ListCommandLine(ListCommandLine p)
{
  switch(p->kind)
  {
  case is_ConsCmdLine:
    return make_ConsCmdLine
      ( clone_CommandLine(p->u.conscmdline_.commandline_)
      , clone_ListCommandLine(p->u.conscmdline_.listcommandline_)
      );

  case is_NilCmdLine:
    return make_NilCmdLine ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning ListCommandLine!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Input(Input p)
{
  switch(p->kind)
  {
  case is_StartInput:
    free_ListJob(p->u.startinput_.listjob_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Input!\n");
    exit(1);
  }
  free(p);
}

void free_Job(Job p)
{
  switch(p->kind)
  {
  case is_OneJobFG:
    free_CommandLine(p->u.onejobfg_.commandline_);
    break;

  case is_OneJobBG:
    free_CommandLine(p->u.onejobbg_.commandline_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Job!\n");
    exit(1);
  }
  free(p);
}

void free_ListJob(ListJob p)
{
  switch(p->kind)
  {
  case is_SeparatorJob:
    free_Job(p->u.separatorjob_.job_);
    free_ListJob(p->u.separatorjob_.listjob_);
    break;

  case is_ConsJob:
    free_Job(p->u.consjob_.job_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ListJob!\n");
    exit(1);
  }
  free(p);
}

void free_CommandLine(CommandLine p)
{
  switch(p->kind)
  {
  case is_MkCmdLine:
    free_Pipeline(p->u.mkcmdline_.pipeline_);
    free_OptRedir(p->u.mkcmdline_.optredir_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CommandLine!\n");
    exit(1);
  }
  free(p);
}

void free_OptRedir(OptRedir p)
{
  switch(p->kind)
  {
  case is_NoRedir:
    break;

  case is_InOutRedir:
    free(p->u.inoutredir_.word_1);
    free(p->u.inoutredir_.word_2);
    break;

  case is_OutInRedir:
    free(p->u.outinredir_.word_1);
    free(p->u.outinredir_.word_2);
    break;

  case is_OutRedir:
    free(p->u.outredir_.word_);
    break;

  case is_InRedir:
    free(p->u.inredir_.word_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OptRedir!\n");
    exit(1);
  }
  free(p);
}

void free_Pipeline(Pipeline p)
{
  switch(p->kind)
  {
  case is_Single:
    free_CommandPart(p->u.single_.commandpart_);
    break;

  case is_Pipe:
    free_CommandPart(p->u.pipe_.commandpart_);
    free_Pipeline(p->u.pipe_.pipeline_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Pipeline!\n");
    exit(1);
  }
  free(p);
}

void free_CommandPart(CommandPart p)
{
  switch(p->kind)
  {
  case is_Cmd:
    free(p->u.cmd_.word_);
    break;

  case is_CmdWithArgs:
    free(p->u.cmdwithargs_.word_);
    free_ListWordComponent(p->u.cmdwithargs_.listwordcomponent_);
    break;

  case is_CmdAssign:
    free(p->u.cmdassign_.word_1);
    free(p->u.cmdassign_.word_2);
    break;

  case is_VarExpand:
    free(p->u.varexpand_.word_);
    break;

  case is_IfCmd:
    free_Pipeline(p->u.ifcmd_.pipeline_);
    free_ListCommandLine(p->u.ifcmd_.listcommandline_);
    break;

  case is_IfElseCmd:
    free_Pipeline(p->u.ifelsecmd_.pipeline_);
    free_ListCommandLine(p->u.ifelsecmd_.listcommandline_1);
    free_ListCommandLine(p->u.ifelsecmd_.listcommandline_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CommandPart!\n");
    exit(1);
  }
  free(p);
}

void free_WordComponent(WordComponent p)
{
  switch(p->kind)
  {
  case is_LitWord:
    free(p->u.litword_.word_);
    break;

  case is_VarWord:
    free(p->u.varword_.word_);
    break;

  case is_SubCmd:
    free_Pipeline(p->u.subcmd_.pipeline_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing WordComponent!\n");
    exit(1);
  }
  free(p);
}

void free_ListWordComponent(ListWordComponent p)
{
  switch(p->kind)
  {
  case is_SingleWordComponent:
    free_WordComponent(p->u.singlewordcomponent_.wordcomponent_);
    break;

  case is_ConsWordComponent:
    free_WordComponent(p->u.conswordcomponent_.wordcomponent_);
    free_ListWordComponent(p->u.conswordcomponent_.listwordcomponent_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ListWordComponent!\n");
    exit(1);
  }
  free(p);
}

void free_ListCommandLine(ListCommandLine p)
{
  switch(p->kind)
  {
  case is_ConsCmdLine:
    free_CommandLine(p->u.conscmdline_.commandline_);
    free_ListCommandLine(p->u.conscmdline_.listcommandline_);
    break;

  case is_NilCmdLine:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ListCommandLine!\n");
    exit(1);
  }
  free(p);
}

